#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    powerExpanderBattery, sensorAnalog)
#pragma config(Sensor, dgtl11, PTO,            sensorDigitalOut)
#pragma config(Sensor, dgtl12, pincer,         sensorDigitalOut)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           arm_l1,        tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port3,           arm_l2,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           arm_l3,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           chassis_l,     tmotorVex393_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port6,           chassis_r,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port7,           arm_r3,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           arm_r2,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           arm_r1,        tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)
#include "Mod_Vex_Comp_Control.c"
#include "motor.h"
#include "RerunFunctions.c"
#include "Autons.h"

int iDes;
void
armControl( bool bBtnUp, bool bBtnDown ) {
	if( bBtnUp || bBtnDown ) {
		arm( 127 * (bBtnUp - bBtnDown) );
		iDes = (SensorValue[ I2C_1 ] + -SensorValue[ I2C_2 ]) / 2;
	} else {
		arm( iArmPID(iDes) );
	}
}

void
init( ) {
	strTeam = "Larry ~ 21S";
	bLCDAuton =
	bLCDUserControl =  true;
	
	if( nLCDButtons != 0 ) {
	}
}

const int kMin = 1;
const int kMax = 2;
int iAutonSelected = kMin;

void
pre_auton( ) {	
	bool bLCD = nLCDButtons != 0 ? true : false;
	string strAutoName;
	while( bLCD ) {
		if( nLCDButtons == 1 ) {
			waitForRelease( );
			iAutonSelected = iAutonSelected == kMin ? kMax : iAutonSelected - 1;
		} 
		else if( nLCDButtons == 4 ) {
			waitForRelease( );
			iAutonSelected = iAutonSelected == kMax ? kMin : iAutonSelected + 1;
		} 
		else if( nLCDButtons == 2 ) {
			waitForRelease( );
			bLCD = false;
		}
		
		switch( iAutonSelected ) {
			case 1:  strAutoName = "Back Stars"; break;
			case 2:  strAutoName = "Cube";       break;
			default: strAutoName = "Error";      break;
		}
		
		displayLCDCenteredString( 0, strAutoName );
		displayLCDCenteredString( 1, "<    Select    >" );
		delay( 50 );
		clearLCDLines( );
	}
	
	clearAllIME( );
}

task
autonomous( ) {
	clearAllIME( );
	switch( iAutonSelected ) {
		case 1:  backStars( ); break;
		case 2:  cube( );      break;
		default: driveBack( ); break;
	}

	/* Stop the robot */
	auton( 0, 0, 0, 0, 0, 0, 0 );
}

task
teleop( ) {
	while( true ) {
		tank( vexRT[ Ch3 ], vexRT[ Ch2 ] );
		armControl( vexRT[ Btn6U ], vexRT[ Btn6D ] );

		if( vexRT[ Btn5U ] ) 
			SensorValue[ pincer ] = true;
		else if( vexRT[ Btn5D ] ) 
			SensorValue[ pincer ] = false;

		if( vexRT[ Btn7D ] ) {
			waitForReleased7D( );
			startTask( record );
		}

		delay( 20 );
	}
}
